<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="常见加密算法">
<meta property="og:type" content="article">
<meta property="og:title" content="常用加密算法">
<meta property="og:url" content="https://username.github.io/2022/07/02/%E5%B8%B8%E8%A7%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="鱼先生的格纳库">
<meta property="og:description" content="常见加密算法">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/745921536/MyImagepost/main/img/202208292026413">
<meta property="og:image" content="https://raw.githubusercontent.com/745921536/MyImagepost/main/img/202208292027429">
<meta property="og:image" content="https://ctf-wiki.org/crypto/hash/figure/hash.png">
<meta property="og:image" content="https://raw.githubusercontent.com/745921536/MyImagepost/main/img/202209041346558.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/745921536/MyImagepost/main/img/202209041348454.png">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-e160744c78b680b008c165cb78841858_720w.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/745921536/MyImagepost/main/img/202209041349478.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/745921536/MyImagepost/main/img/202209041349435.png">
<meta property="og:image" content="https://raw.githubusercontent.com/745921536/MyImagepost/main/img/202209041351444.png">
<meta property="og:image" content="https://raw.githubusercontent.com/745921536/MyImagepost/main/img/202209041353792.png">
<meta property="og:image" content="https://raw.githubusercontent.com/745921536/MyImagepost/main/img/202209041400761.png">
<meta property="og:image" content="https://raw.githubusercontent.com/745921536/MyImagepost/main/img/202209041400753.png">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-29de65eb93c100c547f7bd92eb95c9ca_720w.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-3027156eb00bcddcdac69657c8aad1e7_720w.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-772b661b3a89b1b3d7ec5fd0a47652e9_720w.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/745921536/MyImagepost/main/img/202209041406051.png">
<meta property="og:image" content="https://raw.githubusercontent.com/745921536/MyImagepost/main/img/202209041420462.jpg">
<meta property="article:published_time" content="2022-07-02T11:29:48.000Z">
<meta property="article:modified_time" content="2022-09-04T06:41:23.344Z">
<meta property="article:author" content="没有眼的鱼">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/745921536/MyImagepost/main/img/202208292026413"><title>常用加密算法 | 鱼先生的格纳库</title><link ref="canonical" href="https://username.github.io/2022/07/02/%E5%B8%B8%E8%A7%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.2"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">鱼先生的格纳库</div><div class="header-banner-info__subtitle">没有眼的鱼</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">常用加密算法</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-07-02</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-09-04</span></span></div></header><div class="post-body">
        <h1 id="常见加密算法"   >
          <a href="#常见加密算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#常见加密算法" class="headerlink" title="常见加密算法"></a>常见加密算法</h1>
      
        <h2 id="Tea加密及其变种"   >
          <a href="#Tea加密及其变种" class="heading-link"><i class="fas fa-link"></i></a><a href="#Tea加密及其变种" class="headerlink" title="Tea加密及其变种"></a>Tea加密及其变种</h2>
      <p>注意Tea，xTea和xxTea都是分组算法，输入会被分为以若干个字节组成的组元，逆向时要注意类型的转换</p>
<p>若寄存器溢出还得加上<code>&amp;0xffffffff</code></p>

        <h3 id="Tea"   >
          <a href="#Tea" class="heading-link"><i class="fas fa-link"></i></a><a href="#Tea" class="headerlink" title="Tea"></a>Tea</h3>
      <p>在密码学中，<strong>微型加密算法</strong>（Tiny Encryption Algorithm，TEA）是一种易于描述和执行的块密码，通常只需要很少的代码就可实现。</p>
<p><img src="https://raw.githubusercontent.com/745921536/MyImagepost/main/img/202208292026413" alt="img"></p>
<p>代码样例</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//加密函数  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">encrypt</span> <span class="params">(<span class="type">uint32_t</span>* v, <span class="type">uint32_t</span>* k)</span> &#123;  </span><br><span class="line">    <span class="type">uint32_t</span> v0=v[<span class="number">0</span>], v1=v[<span class="number">1</span>], sum=<span class="number">0</span>, i;           <span class="comment">/* set up */</span>  </span><br><span class="line">    <span class="type">uint32_t</span> delta=<span class="number">0x9e3779b9</span>;                     <span class="comment">//magic number</span></span><br><span class="line">    <span class="type">uint32_t</span> k0=k[<span class="number">0</span>], k1=k[<span class="number">1</span>], k2=k[<span class="number">2</span>], k3=k[<span class="number">3</span>];   <span class="comment">/* cache key */</span>  </span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;                       <span class="comment">/* basic cycle start */</span>  </span><br><span class="line">        sum += delta;  </span><br><span class="line">        v0 += ((v1&lt;&lt;<span class="number">4</span>) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;<span class="number">5</span>) + k1);  </span><br><span class="line">        v1 += ((v0&lt;&lt;<span class="number">4</span>) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;<span class="number">5</span>) + k3);  </span><br><span class="line">    &#125;                                              <span class="comment">/* end cycle */</span>  </span><br><span class="line">    v[<span class="number">0</span>]=v0; v[<span class="number">1</span>]=v1;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//解密函数  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">decrypt</span> <span class="params">(<span class="type">uint32_t</span>* v, <span class="type">uint32_t</span>* k)</span> &#123;  </span><br><span class="line">    <span class="type">uint32_t</span> v0=v[<span class="number">0</span>], v1=v[<span class="number">1</span>], sum=<span class="number">0xC6EF3720</span>, i;  <span class="comment">//sum = 次数 * magic number</span></span><br><span class="line">    <span class="type">uint32_t</span> delta=<span class="number">0x9e3779b9</span>;                     <span class="comment">//magic number </span></span><br><span class="line">    <span class="type">uint32_t</span> k0=k[<span class="number">0</span>], k1=k[<span class="number">1</span>], k2=k[<span class="number">2</span>], k3=k[<span class="number">3</span>];   <span class="comment">/* cache key */</span>  </span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">32</span>; i++) &#123;                         <span class="comment">/* basic cycle start */</span>  </span><br><span class="line">        v1 -= ((v0&lt;&lt;<span class="number">4</span>) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;<span class="number">5</span>) + k3);  </span><br><span class="line">        v0 -= ((v1&lt;&lt;<span class="number">4</span>) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;<span class="number">5</span>) + k1);  </span><br><span class="line">        sum -= delta;  </span><br><span class="line">    &#125;                                              <span class="comment">/* end cycle */</span>  </span><br><span class="line">    v[<span class="number">0</span>]=v0; v[<span class="number">1</span>]=v1;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">uint32_t</span> v[<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,k[<span class="number">4</span>]=&#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;  </span><br><span class="line">    <span class="comment">// v为要加密的数据是两个32位无符号整数  </span></span><br><span class="line">    <span class="comment">// k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位  </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;加密前原始数据：%u %u\n&quot;</span>,v[<span class="number">0</span>],v[<span class="number">1</span>]);  </span><br><span class="line">    encrypt(v, k);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;加密后的数据：%u %u\n&quot;</span>,v[<span class="number">0</span>],v[<span class="number">1</span>]);  </span><br><span class="line">    decrypt(v, k);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;解密后的数据：%u %u\n&quot;</span>,v[<span class="number">0</span>],v[<span class="number">1</span>]);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></div></figure>

<p>TEA算法有64位的明文，128位的密钥以及一个常数 $\delta$ 组成。$\delta$源自于黄金比例，但它的数值的精确度并不重要，于是被定义为 $\delta$=「($\tilde{A}$5 - 1)231」(即程序里面的<strong>0×9E3779B9</strong>)</p>
<p>TEA是将明文每64位位一组进行加密，每次加密将这64位分为两部分，高32位和低32位(后面分别用Mup和Mdown来表示)，而密钥(Key)则拆分为4部分。</p>
<p>一般的轮数是32或64（8的倍数），加密后将结果覆写回去</p>
<p>注意，x-=0x61c88647和x+=0x9e3779b9，这两个值是等价的，可能会在反汇编中看到</p>
<p>这里将上面测试的代码编译好拖入IDA中进行观察</p>
<p>可以看到δ就被反编译为<code>v4 -= 1640531527;</code></p>
<p>代码样例</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">decrypt</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span>* EntryData, <span class="type">unsigned</span> <span class="type">long</span>* Key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> Mup = EntryData[<span class="number">0</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> Mdown = EntryData[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> delta = <span class="number">0xD33B470</span>;</span><br><span class="line"> 	<span class="type">int</span> n=<span class="number">32</span>;</span><br><span class="line">        </span><br><span class="line">   	sum = delta*n; <span class="comment">//视次数.</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        Mdown -= ((Mup &lt;&lt; <span class="number">4</span>) + Key[<span class="number">2</span>]) ^ (Mup + sum) ^ ((Mup &gt;&gt; <span class="number">5</span>) + Key[<span class="number">3</span>]);</span><br><span class="line">        Mup -= ((Mdown &lt;&lt; <span class="number">4</span>) + Key[<span class="number">0</span>]) ^ (Mdown + sum) ^ ((Mdown &gt;&gt; <span class="number">5</span>) + Key[<span class="number">1</span>]);</span><br><span class="line">        sum -= delta;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    EntryData[<span class="number">0</span>] = Mup;</span><br><span class="line">    EntryData[<span class="number">1</span>] = Mdown;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> key[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> EntryData[] = &#123;<span class="number">0x89546517</span>, <span class="number">0x324665ed</span>&#125;;</span><br><span class="line">    <span class="built_in">decrypt</span>(EntryData, key);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;                      </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, EntryData[j] &amp; <span class="number">0xff</span>);</span><br><span class="line">                EntryData[j] &gt;&gt;= <span class="number">8</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    </span></span><br><span class="line"><span class="comment">//0x89546517, 0x324665ed  0xfda9583d, 0x97615ee2 0x91f160e4, 0xa2e9e973  0x999acb59, 0x7de1b1ec</span></span><br><span class="line"><span class="comment">//moectf&#123;Th3_TEA_!S_s0_t4s7y~~!!!&#125;</span></span><br></pre></td></tr></table></div></figure>




        <h3 id="xTea"   >
          <a href="#xTea" class="heading-link"><i class="fas fa-link"></i></a><a href="#xTea" class="headerlink" title="xTea"></a>xTea</h3>
      <p>xTea算法是Tea的升级版，加入了位移和异或运算，和更多的密钥表</p>
<p><img src="https://raw.githubusercontent.com/745921536/MyImagepost/main/img/202208292027429" alt="img"></p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">/* take 64 bits of data in v[0] and v[1] and 128 bits of key[0] - key[3] */</span>  </span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">encipher</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> num_rounds, <span class="type">uint32_t</span> v[<span class="number">2</span>], <span class="type">uint32_t</span> <span class="type">const</span> key[<span class="number">4</span>])</span> &#123;  </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i;  </span><br><span class="line">    <span class="type">uint32_t</span> v0=v[<span class="number">0</span>], v1=v[<span class="number">1</span>], sum=<span class="number">0</span>, delta=<span class="number">0x9E3779B9</span>;  </span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; num_rounds; i++) &#123;  </span><br><span class="line">        v0 += (((v1 &lt;&lt; <span class="number">4</span>) ^ (v1 &gt;&gt; <span class="number">5</span>)) + v1) ^ (sum + key[sum &amp; <span class="number">3</span>]);  </span><br><span class="line">        sum += delta;  </span><br><span class="line">        v1 += (((v0 &lt;&lt; <span class="number">4</span>) ^ (v0 &gt;&gt; <span class="number">5</span>)) + v0) ^ (sum + key[(sum&gt;&gt;<span class="number">11</span>) &amp; <span class="number">3</span>]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    v[<span class="number">0</span>]=v0; v[<span class="number">1</span>]=v1;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">decipher</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> num_rounds, <span class="type">uint32_t</span> v[<span class="number">2</span>], <span class="type">uint32_t</span> <span class="type">const</span> key[<span class="number">4</span>])</span> &#123;  </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i;  </span><br><span class="line">    <span class="type">uint32_t</span> v0=v[<span class="number">0</span>], v1=v[<span class="number">1</span>], delta=<span class="number">0x9E3779B9</span>, sum=delta*num_rounds;  </span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; num_rounds; i++) &#123;  </span><br><span class="line">        v1 -= (((v0 &lt;&lt; <span class="number">4</span>) ^ (v0 &gt;&gt; <span class="number">5</span>)) + v0) ^ (sum + key[(sum&gt;&gt;<span class="number">11</span>) &amp; <span class="number">3</span>]);  </span><br><span class="line">        sum -= delta;  </span><br><span class="line">        v0 -= (((v1 &lt;&lt; <span class="number">4</span>) ^ (v1 &gt;&gt; <span class="number">5</span>)) + v1) ^ (sum + key[sum &amp; <span class="number">3</span>]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    v[<span class="number">0</span>]=v0; v[<span class="number">1</span>]=v1;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">uint32_t</span> v[<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;  </span><br><span class="line">    <span class="type">uint32_t</span> <span class="type">const</span> k[<span class="number">4</span>]=&#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;  </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> r=<span class="number">32</span>;<span class="comment">//num_rounds建议取值为32  </span></span><br><span class="line">    <span class="comment">// v为要加密的数据是两个32位无符号整数  </span></span><br><span class="line">    <span class="comment">// k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位  </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;加密前原始数据：%u %u\n&quot;</span>,v[<span class="number">0</span>],v[<span class="number">1</span>]);  </span><br><span class="line">    encipher(r, v, k);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;加密后的数据：%u %u\n&quot;</span>,v[<span class="number">0</span>],v[<span class="number">1</span>]);  </span><br><span class="line">    decipher(r, v, k);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;解密后的数据：%u %u\n&quot;</span>,v[<span class="number">0</span>],v[<span class="number">1</span>]);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></div></figure>

<p>整体逆向和Tea差不太大</p>

        <h3 id="xxTea"   >
          <a href="#xxTea" class="heading-link"><i class="fas fa-link"></i></a><a href="#xxTea" class="headerlink" title="xxTea"></a>xxTea</h3>
      <p>xxTEA，又称Corrected Block TEA</p>
<p>特点：原字符串长度可以不是4的倍数了</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> MX (z&gt;&gt;5^y<span class="string">&lt;&lt;2) + (y&gt;</span>&gt;3 ^ z&lt;&lt;4)^(sum^y) + (k[ i&amp;3 ^ e] ^ z);</span></span><br><span class="line"> </span><br><span class="line">  <span class="type">long</span> <span class="title function_">btea</span><span class="params">(<span class="type">long</span>* v, <span class="type">long</span> n, <span class="type">long</span>* k)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> z=v[n<span class="number">-1</span>], y=v[<span class="number">0</span>], sum=<span class="number">0</span>, e, DELTA=<span class="number">0x9e3779b9</span>;</span><br><span class="line">    <span class="type">long</span> i, q ;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) &#123;         </span><br><span class="line">      q = <span class="number">6</span> + <span class="number">52</span>/n;</span><br><span class="line">      <span class="keyword">while</span> (q-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sum += DELTA;</span><br><span class="line">        e = (sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)&#123; </span><br><span class="line">            y = v[i+<span class="number">1</span>];</span><br><span class="line">            z = v[i] += MX;</span><br><span class="line">        &#125; </span><br><span class="line">        y = v[<span class="number">0</span>];</span><br><span class="line">        z = v[n<span class="number">-1</span>] += MX;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125; </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">-1</span>) &#123; </span><br><span class="line">      n = -n;</span><br><span class="line">      q = <span class="number">6</span> + <span class="number">52</span>/n;</span><br><span class="line">      sum = q*DELTA ;</span><br><span class="line">      <span class="keyword">while</span> (sum != <span class="number">0</span>) &#123;</span><br><span class="line">        e = (sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (i=n<span class="number">-1</span>; i&gt;<span class="number">0</span>; i--) &#123;</span><br><span class="line">            z = v[i<span class="number">-1</span>];</span><br><span class="line">            y = v[i] -= MX;   </span><br><span class="line">        &#125;</span><br><span class="line">        z = v[n<span class="number">-1</span>];</span><br><span class="line">        y = v[<span class="number">0</span>] -= MX;</span><br><span class="line">        sum -= DELTA;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> long btea(long* v, long n, long* k)</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">v是要加密的组元的起始地址，以32bit为单位，这里用long来实现。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">n是要加密的组元个数，正数是加密，负数是解密。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">k是密钥的起始地址，长度为4个组元，4*32=128bit。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">返回值为0或1（对应n=0，没有计算）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">加密的结果会直接写回到v中。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></div></figure>




        <h2 id="Base64"   >
          <a href="#Base64" class="heading-link"><i class="fas fa-link"></i></a><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h2>
      <p>Base64 是一种基于 64 个可打印字符来表示二进制数据的表示方法。</p>
<p><strong>特征：由64个字符(A-Z,a-z,0-9,+,/)组成，末尾可能会出现1或2个’=’ 最多有2个</strong></p>
<p>对二进制数据以6个位(bit)为一组切分，所以分切之前的二进制位数应该是24的倍数（即6，8的最小公倍数）。如果不足24位,则在编码后数据后面添加”=”</p>
<p>转换的时候，将 3 字节的数据，先后放入一个 24 位的缓冲区中，先来的字节占高位。数据不足 3 字节的话，于缓冲器中剩下的比特用 0 补足。每次取出 6 比特，按照其值选择<code>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/</code>中的字符作为编码后的输出，直到全部输入数据转换完成。</p>
<p>通常而言 Base64 的识别特征为索引表，当我们能找到 <code>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/</code> 这样索引表，再经过简单的分析基本就能判定是 Base64 编码。</p>
<p>当然，有些题目 base64 的索引表是会变的，一些变种的 base64 主要 就是修改了这个索引表。</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">文本:        V        a        n</span><br><span class="line">ASCII:      86       97      110</span><br><span class="line">Bin:    010101|10 0110|0001 01|101110</span><br><span class="line">6位一组：  21      38      5      46 </span><br><span class="line">Base64:   V       m       F      u</span><br></pre></td></tr></table></div></figure>

<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 码表</span></span><br><span class="line">s = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">My_base64_encode</span>(<span class="params">inputs</span>):</span><br><span class="line">    <span class="comment"># 将字符串转化为2进制</span></span><br><span class="line">    bin_str = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> inputs:</span><br><span class="line">        x = <span class="built_in">str</span>(<span class="built_in">bin</span>(<span class="built_in">ord</span>(i))).replace(<span class="string">&#x27;0b&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        bin_str.append(<span class="string">&#x27;&#123;:0&gt;8&#125;&#x27;</span>.<span class="built_in">format</span>(x))</span><br><span class="line">    <span class="comment"># print(bin_str)</span></span><br><span class="line">    <span class="comment"># 输出的字符串</span></span><br><span class="line">    outputs = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 不够三倍数，需补齐的次数</span></span><br><span class="line">    nums = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> bin_str:</span><br><span class="line">        <span class="comment"># 每次取三个字符的二进制</span></span><br><span class="line">        temp_list = bin_str[:<span class="number">3</span>]</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">len</span>(temp_list) != <span class="number">3</span>):</span><br><span class="line">            nums = <span class="number">3</span> - <span class="built_in">len</span>(temp_list)</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(temp_list) &lt; <span class="number">3</span>:</span><br><span class="line">                temp_list += [<span class="string">&#x27;0&#x27;</span> * <span class="number">8</span>]</span><br><span class="line">        temp_str = <span class="string">&quot;&quot;</span>.join(temp_list)</span><br><span class="line">        <span class="comment"># print(temp_str)</span></span><br><span class="line">        <span class="comment"># 将三个8字节的二进制转换为4个十进制</span></span><br><span class="line">        temp_str_list = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">4</span>):</span><br><span class="line">            temp_str_list.append(<span class="built_in">int</span>(temp_str[i * <span class="number">6</span>:(i + <span class="number">1</span>) * <span class="number">6</span>], <span class="number">2</span>))</span><br><span class="line">        <span class="comment"># print(temp_str_list)</span></span><br><span class="line">        <span class="keyword">if</span> nums:</span><br><span class="line">            temp_str_list = temp_str_list[<span class="number">0</span>:<span class="number">4</span> - nums]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> temp_str_list:</span><br><span class="line">            outputs += s[i]</span><br><span class="line">        bin_str = bin_str[<span class="number">3</span>:]</span><br><span class="line">    outputs += nums * <span class="string">&#x27;=&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Encrypted String:\n%s &quot;</span> % outputs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">My_base64_decode</span>(<span class="params">inputs</span>):</span><br><span class="line">    <span class="comment"># 将字符串转化为2进制</span></span><br><span class="line">    bin_str = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> inputs:</span><br><span class="line">        <span class="keyword">if</span> i != <span class="string">&#x27;=&#x27;</span>:</span><br><span class="line">            x = <span class="built_in">str</span>(<span class="built_in">bin</span>(s.index(i))).replace(<span class="string">&#x27;0b&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            bin_str.append(<span class="string">&#x27;&#123;:0&gt;6&#125;&#x27;</span>.<span class="built_in">format</span>(x))</span><br><span class="line">    <span class="comment"># print(bin_str)</span></span><br><span class="line">    <span class="comment"># 输出的字符串</span></span><br><span class="line">    outputs = <span class="string">&quot;&quot;</span></span><br><span class="line">    nums = inputs.count(<span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">    <span class="keyword">while</span> bin_str:</span><br><span class="line">        temp_list = bin_str[:<span class="number">4</span>]</span><br><span class="line">        temp_str = <span class="string">&quot;&quot;</span>.join(temp_list)</span><br><span class="line">        <span class="comment"># print(temp_str)</span></span><br><span class="line">        <span class="comment"># 补足8位字节</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">len</span>(temp_str) % <span class="number">8</span> != <span class="number">0</span>):</span><br><span class="line">            temp_str = temp_str[<span class="number">0</span>:-<span class="number">1</span> * nums * <span class="number">2</span>]</span><br><span class="line">        <span class="comment"># 将四个6字节的二进制转换为三个字符</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">int</span>(<span class="built_in">len</span>(temp_str) / <span class="number">8</span>)):</span><br><span class="line">            outputs += <span class="built_in">chr</span>(<span class="built_in">int</span>(temp_str[i * <span class="number">8</span>:(i + <span class="number">1</span>) * <span class="number">8</span>], <span class="number">2</span>))</span><br><span class="line">        bin_str = bin_str[<span class="number">4</span>:]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Decrypted String:\n%s &quot;</span> % outputs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;     *************************************&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;     *    (1)encode         (2)decode    *&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;     *************************************&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">num = <span class="built_in">input</span>(<span class="string">&quot;Please select the operation you want to perform:\n&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> (num == <span class="string">&quot;1&quot;</span>):</span><br><span class="line">    input_str = <span class="built_in">input</span>(<span class="string">&quot;Please enter a string that needs to be encrypted: \n&quot;</span>)</span><br><span class="line">    My_base64_encode(input_str)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    input_str = <span class="built_in">input</span>(<span class="string">&quot;Please enter a string that needs to be decrypted: \n&quot;</span>)</span><br><span class="line">    My_base64_decode(input_str)</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>




        <h2 id="哈希函数"   >
          <a href="#哈希函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2>
      <p>哈希函数（Hash Function）把消息或数据压缩成摘要，使得数据量变小。</p>
<img src="https://ctf-wiki.org/crypto/hash/figure/hash.png" alt="img" style="zoom: 50%;" />

<p>显然对于任何一个 hash 值，理论上存在若干个消息与之对应，即碰撞。</p>
<p>目前的 Hash 函数主要有 MD5，SHA1，SHA256，SHA512。目前的大多数 hash 函数都是迭代性的，即使用同一个 hash 函数，不同的参数进行多次迭代运算。</p>
<div class="table-container"><table>
<thead>
<tr>
<th>算法类型</th>
<th>输出hash值的长度</th>
</tr>
</thead>
<tbody><tr>
<td>MD5</td>
<td>128bit</td>
</tr>
<tr>
<td>SHA1</td>
<td>160bit</td>
</tr>
<tr>
<td>SHA256</td>
<td>256bit</td>
</tr>
<tr>
<td>SHA512</td>
<td>512bit</td>
</tr>
</tbody></table></div>

        <h3 id="MD5"   >
          <a href="#MD5" class="heading-link"><i class="fas fa-link"></i></a><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h3>
      <p><strong>MD5 消息摘要算法</strong>（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个 128 位（16 字节）的散列值（hash value），用于确保信息传输完整一致。MD5 由美国密码学家罗纳德 · 李维斯特（Ronald Linn Rivest）设计，于 1992 年公开，用以取代 MD4 算法。这套算法的程序在 RFC 1321 中被加以规范。</p>
<p>MD5编码具有单向性，即由明文变密文简单，由密文变明文困难。基于这个特性，MD5可以有效保证信息的完整性，常用于验证数据是否被篡改</p>
<p>MD5是不可逆的算法，同一个MD5的值对应无数种密文</p>
<ol>
<li>MD5码以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由4个32位分组组成，并级联后将生成一个128位散列值。</li>
<li>继续向后取512位数据，不够则进行填充。每次的运算都由前一轮的128位散列值和当前的512bit值进行运算</li>
<li>因此MD5结果值是一段固定长度的数据，无论原始数据是多长或多短，其MD5值都是128bit</li>
<li>最后按十六进制计算输出，即结果为0-9a-f</li>
</ol>
<p>伪代码</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">/Note: All variables are unsigned <span class="number">32</span> bits <span class="keyword">and</span> wrap modulo <span class="number">2</span>^<span class="number">32</span> when calculating</span><br><span class="line">var <span class="built_in">int</span>[<span class="number">64</span>] r, k</span><br><span class="line"></span><br><span class="line">//r specifies the per-<span class="built_in">round</span> shift amounts</span><br><span class="line">r[ <span class="number">0.</span><span class="number">.15</span>]：= &#123;<span class="number">7</span>, <span class="number">12</span>, <span class="number">17</span>, <span class="number">22</span>,  <span class="number">7</span>, <span class="number">12</span>, <span class="number">17</span>, <span class="number">22</span>,  <span class="number">7</span>, <span class="number">12</span>, <span class="number">17</span>, <span class="number">22</span>,  <span class="number">7</span>, <span class="number">12</span>, <span class="number">17</span>, <span class="number">22</span>&#125; </span><br><span class="line">r[<span class="number">16.</span><span class="number">.31</span>]：= &#123;<span class="number">5</span>,  <span class="number">9</span>, <span class="number">14</span>, <span class="number">20</span>,  <span class="number">5</span>,  <span class="number">9</span>, <span class="number">14</span>, <span class="number">20</span>,  <span class="number">5</span>,  <span class="number">9</span>, <span class="number">14</span>, <span class="number">20</span>,  <span class="number">5</span>,  <span class="number">9</span>, <span class="number">14</span>, <span class="number">20</span>&#125;</span><br><span class="line">r[<span class="number">32.</span><span class="number">.47</span>]：= &#123;<span class="number">4</span>, <span class="number">11</span>, <span class="number">16</span>, <span class="number">23</span>,  <span class="number">4</span>, <span class="number">11</span>, <span class="number">16</span>, <span class="number">23</span>,  <span class="number">4</span>, <span class="number">11</span>, <span class="number">16</span>, <span class="number">23</span>,  <span class="number">4</span>, <span class="number">11</span>, <span class="number">16</span>, <span class="number">23</span>&#125;</span><br><span class="line">r[<span class="number">48.</span><span class="number">.63</span>]：= &#123;<span class="number">6</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">21</span>,  <span class="number">6</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">21</span>,  <span class="number">6</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">21</span>,  <span class="number">6</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">21</span>&#125;</span><br><span class="line"></span><br><span class="line">//Use binary integer part of the sines of integers <span class="keyword">as</span> constants:</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">from</span> <span class="number">0</span> to <span class="number">63</span></span><br><span class="line">    k[i] := floor(<span class="built_in">abs</span>(sin(i + <span class="number">1</span>)) × <span class="number">2</span>^<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">//Initialize variables:</span><br><span class="line">var <span class="built_in">int</span> h0 := <span class="number">0x67452301</span></span><br><span class="line">var <span class="built_in">int</span> h1 := <span class="number">0xEFCDAB89</span></span><br><span class="line">var <span class="built_in">int</span> h2 := <span class="number">0x98BADCFE</span></span><br><span class="line">var <span class="built_in">int</span> h3 := <span class="number">0x10325476</span></span><br><span class="line"></span><br><span class="line">//Pre-processing:</span><br><span class="line">append <span class="string">&quot;1&quot;</span> bit to message</span><br><span class="line">append <span class="string">&quot;0&quot;</span> bits until message length <span class="keyword">in</span> bits ≡ <span class="number">448</span> (mod <span class="number">512</span>)</span><br><span class="line">append bit length of message <span class="keyword">as</span> <span class="number">64</span>-bit little-endian integer to message</span><br><span class="line"></span><br><span class="line">//Process the message <span class="keyword">in</span> successive <span class="number">512</span>-bit chunks:</span><br><span class="line"><span class="keyword">for</span> each <span class="number">512</span>-bit chunk of message</span><br><span class="line">    <span class="keyword">break</span> chunk into sixteen <span class="number">32</span>-bit little-endian words w[i], <span class="number">0</span> ≤ i ≤ <span class="number">15</span></span><br><span class="line"></span><br><span class="line">    //Initialize <span class="built_in">hash</span> value <span class="keyword">for</span> this chunk:</span><br><span class="line">    var <span class="built_in">int</span> a := h0</span><br><span class="line">    var <span class="built_in">int</span> b := h1</span><br><span class="line">    var <span class="built_in">int</span> c := h2</span><br><span class="line">    var <span class="built_in">int</span> d := h3</span><br><span class="line"></span><br><span class="line">    //Main loop:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">from</span> <span class="number">0</span> to <span class="number">63</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> ≤ i ≤ <span class="number">15</span> then</span><br><span class="line">            f := (b <span class="keyword">and</span> c) <span class="keyword">or</span> ((<span class="keyword">not</span> b) <span class="keyword">and</span> d)</span><br><span class="line">            g := i</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> <span class="number">16</span> ≤ i ≤ <span class="number">31</span></span><br><span class="line">            f := (d <span class="keyword">and</span> b) <span class="keyword">or</span> ((<span class="keyword">not</span> d) <span class="keyword">and</span> c)</span><br><span class="line">            g := (<span class="number">5</span>×i + <span class="number">1</span>) mod <span class="number">16</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> <span class="number">32</span> ≤ i ≤ <span class="number">47</span></span><br><span class="line">            f := b xor c xor d</span><br><span class="line">            g := (<span class="number">3</span>×i + <span class="number">5</span>) mod <span class="number">16</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> <span class="number">48</span> ≤ i ≤ <span class="number">63</span></span><br><span class="line">            f := c xor (b <span class="keyword">or</span> (<span class="keyword">not</span> d))</span><br><span class="line">            g := (<span class="number">7</span>×i) mod <span class="number">16</span></span><br><span class="line"></span><br><span class="line">        temp := d</span><br><span class="line">        d := c</span><br><span class="line">        c := b</span><br><span class="line">        b := leftrotate((a + f + k[i] + w[g]),r[i]) + b</span><br><span class="line">        a := temp</span><br><span class="line">    Next i</span><br><span class="line">    //Add this chunk<span class="string">&#x27;s hash to result so far:</span></span><br><span class="line"><span class="string">    h0 := h0 + a</span></span><br><span class="line"><span class="string">    h1 := h1 + b </span></span><br><span class="line"><span class="string">    h2 := h2 + c</span></span><br><span class="line"><span class="string">    h3 := h3 + d</span></span><br><span class="line"><span class="string">End ForEach</span></span><br><span class="line"><span class="string">var int digest := h0 append h1 append h2 append h3 //(expressed as little-endian)</span></span><br></pre></td></tr></table></div></figure>

<p><strong>特征</strong></p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">h0 = <span class="number">0x67452301</span>;</span><br><span class="line">h1 = <span class="number">0xefcdab89</span>;</span><br><span class="line">h2 = <span class="number">0x98badcfe</span>;</span><br><span class="line">h3 = <span class="number">0x10325476</span>;</span><br></pre></td></tr></table></div></figure>

<p><strong>攻击方法</strong></p>
<p>上网站碰撞</p>

        <h2 id="RC4"   >
          <a href="#RC4" class="heading-link"><i class="fas fa-link"></i></a><a href="#RC4" class="headerlink" title="RC4"></a>RC4</h2>
      <p>RC4是一种流加密算法，密钥长度可变，加解密使用相同的密钥，算是对称加密算法</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rc4_init</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *s, <span class="type">unsigned</span> <span class="type">char</span> *key, <span class="type">unsigned</span> <span class="type">long</span> Len)</span> <span class="comment">//初始化函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i =<span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> k[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++) &#123;</span><br><span class="line">        s[i] = i;</span><br><span class="line">        k[i] = key[i%Len];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">256</span>; i++) &#123;</span><br><span class="line">        j=(j+s[i]+k[i])%<span class="number">256</span>;</span><br><span class="line">        tmp = s[i];</span><br><span class="line">        s[i] = s[j]; <span class="comment">//交换s[i]和s[j]</span></span><br><span class="line">        s[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rc4_crypt</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *s, <span class="type">unsigned</span> <span class="type">char</span> *Data, <span class="type">unsigned</span> <span class="type">long</span> Len)</span> <span class="comment">//加解密</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, t = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> tmp;</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;Len;k++) &#123;</span><br><span class="line">        i=(i+<span class="number">1</span>)%<span class="number">256</span>;</span><br><span class="line">        j=(j+s[i])%<span class="number">256</span>;</span><br><span class="line">        tmp = s[i];</span><br><span class="line">        s[i] = s[j]; <span class="comment">//交换s[x]和s[y]</span></span><br><span class="line">        s[j] = tmp;</span><br><span class="line">        t=(s[i]+s[j])%<span class="number">256</span>;</span><br><span class="line">        Data[k] ^= s[t];</span><br><span class="line">     &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//每收到一个字节，就进行循环。通过一定的算法定位 S 盒中的一个元素，并与输入字节异或，得到 k。循环中还改变了 S 盒。如果输入的是明文，输出的就是密文；如果输入的是密文，输出的就是明文。</span></span><br></pre></td></tr></table></div></figure>

<p>RC4 主要包含三个流程</p>
<ul>
<li>初始化 S 和 T 数组。</li>
<li>初始化置换 S。</li>
<li>生成密钥流。</li>
</ul>
<p>初始化S,T数组</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++) &#123;</span><br><span class="line">        s[i] = i;</span><br><span class="line">        k[i] = key[i%Len];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>置换</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">256</span>; i++) &#123;</span><br><span class="line">       j=(j+s[i]+k[i])%<span class="number">256</span>;</span><br><span class="line">       tmp = s[i];</span><br><span class="line">       s[i] = s[j]; <span class="comment">//交换s[i]和s[j]</span></span><br><span class="line">       s[j] = tmp;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>

<p>生成流密钥，并处理Data</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;Len;k++) &#123;</span><br><span class="line">        i=(i+<span class="number">1</span>)%<span class="number">256</span>;</span><br><span class="line">        j=(j+s[i])%<span class="number">256</span>;</span><br><span class="line">        tmp = s[i];</span><br><span class="line">        s[i] = s[j]; <span class="comment">//交换s[x]和s[y]</span></span><br><span class="line">        s[j] = tmp;</span><br><span class="line">        t=(s[i]+s[j])%<span class="number">256</span>;</span><br><span class="line">        Data[k] ^= s[t];</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></div></figure>

<p>由于异或运算的对合性，RC4 加密解密使用同一套算法</p>

        <h2 id="RSA"   >
          <a href="#RSA" class="heading-link"><i class="fas fa-link"></i></a><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h2>
      
        <h2 id="AES"   >
          <a href="#AES" class="heading-link"><i class="fas fa-link"></i></a><a href="#AES" class="headerlink" title="AES"></a>AES</h2>
      <p><strong>高级加密标准</strong>（英语：<strong>A</strong>dvanced <strong>E</strong>ncryption <strong>S</strong>tandard，缩写AES)，在密码学中又称<strong>Rijndael加密法</strong>，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由美国国家标准与技术研究院（NIST）于2001年11月26日发布于FIPS PUB 197，并在2002年5月26日成为有效的标准。2006年，高级加密标准已然成为对称密钥加密中最流行的算法之一。</p>
<p>对称加密，即加密与解密用的是同一套密钥</p>
<p>AES算法主要有四种操作处理，分别是密钥加法层(也叫轮密钥加，英文Add Round Key)、字节代换层(SubByte)、行位移层(Shift Rows)、列混淆层(Mix Column)。而明文x和密钥k都是由16个字节组成的数据(当然密钥还支持192位和256位的长度，暂时不考虑)，它是按照字节的先后顺序从上到下、从左到右进行排列的。而加密出的密文读取顺序也是按照这个顺序读取的，相当于将数组还原成字符串的模样了，然后再解密的时候又是按照4·4数组处理的。</p>
<img src="https://raw.githubusercontent.com/745921536/MyImagepost/main/img/202209041346558.jpg" alt="v2-b22e3bdd7da5ddf5ea6ff71909dac4b7_r" style="zoom: 67%;" />


        <h3 id="密钥加法层"   >
          <a href="#密钥加法层" class="heading-link"><i class="fas fa-link"></i></a><a href="#密钥加法层" class="headerlink" title="密钥加法层"></a><strong>密钥加法层</strong></h3>
      <p>在密钥加法层中有两个输入的参数，分别是明文和子密钥k[0]，而且这两个输入都是128位的。k[0]实际上就等同于密钥k。</p>
<p>在扩展域中加减法操作和异或运算等价，将两个输入的数据进行按字节异或操作就会得到运算的结果。</p>
<img src="https://raw.githubusercontent.com/745921536/MyImagepost/main/img/202209041348454.png" alt="preview" style="zoom:50%;" />


        <h3 id="字节代换层"   >
          <a href="#字节代换层" class="heading-link"><i class="fas fa-link"></i></a><a href="#字节代换层" class="headerlink" title="字节代换层"></a><strong>字节代换层</strong></h3>
      <p>字节代换层的主要功能就是让输入的数据通过S_box表完成从一个字节到另一个字节的映射，这里的S_box表是通过某种方法计算出来的，具体的计算方法将在进阶部分进行介绍，我们基础部分就只给出计算好的S_box结果。S_box表是一个拥有256个字节元素的数组，可以将其定义为一维数组，也可以将其定义为16·16的二维数组，如果将其定义为二维数组，读取S_box数据的方法就是要将输入数据的每个字节的高四位作为第一个下标，第四位作为第二个下标，略有点麻烦。这里建议将其视作一维数组即可。逆S盒与S盒对应，用于解密时对数据处理，我们对解密时的程序处理称作逆字节代换，只是使用的代换表盒加密时不同而已。</p>
<p><strong>S盒</strong></p>
<img src="https://pic1.zhimg.com/80/v2-e160744c78b680b008c165cb78841858_720w.jpg" alt="img" style="zoom: 67%;" />



<p><strong>逆S盒</strong></p>
<img src="https://raw.githubusercontent.com/745921536/MyImagepost/main/img/202209041349478.jpeg" alt="img" style="zoom:67%;" />



<p><strong>加密图示：</strong></p>
<img src="https://raw.githubusercontent.com/745921536/MyImagepost/main/img/202209041349435.png" alt="img" style="zoom:67%;" />


        <h3 id="行位移——ShiftRows"   >
          <a href="#行位移——ShiftRows" class="heading-link"><i class="fas fa-link"></i></a><a href="#行位移——ShiftRows" class="headerlink" title="行位移——ShiftRows"></a><strong>行位移——ShiftRows</strong></h3>
      <p>行位移操作最为简单，它是用来将输入数据作为一个4·4的字节矩阵进行处理的，然后将这个矩阵的字节进行位置上的置换。ShiftRows子层属于AES手动的扩散层，目的是将单个位上的变换扩散到影响整个状态当，从而达到雪崩效应。在加密时行位移处理与解密时的处理相反，我们这里将解密时的处理称作逆行位移。它之所以称作行位移，是因为它只在4·4矩阵的行间进行操作，每行4字节的数据。在加密时，保持矩阵的第一行不变，第二行向左移动8Bit(一个字节)、第三行向左移动2个字节、第四行向左移动3个字节。而在解密时恰恰相反，依然保持第一行不变，将第二行向右移动一个字节、第三行右移2个字节、第四行右移3个字节。操作结束！</p>
<p><strong>正向行位移图解:</strong></p>
<img src="https://raw.githubusercontent.com/745921536/MyImagepost/main/img/202209041351444.png" alt="img" style="zoom:67%;" />

<p><strong>逆向行位移图解:</strong></p>
<img src="https://raw.githubusercontent.com/745921536/MyImagepost/main/img/202209041353792.png" alt="img" style="zoom:67%;" />


        <h3 id="列混淆——MixColumn"   >
          <a href="#列混淆——MixColumn" class="heading-link"><i class="fas fa-link"></i></a><a href="#列混淆——MixColumn" class="headerlink" title="列混淆——MixColumn"></a><strong>列混淆——MixColumn</strong></h3>
      <p>列混淆子层是AES算法中最为复杂的部分，属于扩散层，列混淆操作是AES算法中主要的扩散元素，它混淆了输入矩阵的每一列，使输入的每个字节都会影响到4个输出字节。行位移子层和列混淆子层的组合使得经过三轮处理以后，矩阵的每个字节都依赖于16个明文字节成可能。其中包含了矩阵乘法、伽罗瓦域内加法和乘法的相关知识。</p>
<p>在加密的正向列混淆中，我们要将输入的4·4矩阵左乘一个给定的4·4矩阵。而它们之间的加法、乘法都在扩展域GF(2^8)中进行。</p>
<p><strong>列混淆的代码</strong></p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> MixArray[<span class="number">4</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">    <span class="number">0x02</span>, <span class="number">0x03</span>, <span class="number">0x01</span>, <span class="number">0x01</span>,</span><br><span class="line">    <span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x03</span>, <span class="number">0x01</span>,</span><br><span class="line">    <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x03</span>,</span><br><span class="line">    <span class="number">0x03</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x02</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MixColum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>(*PlainArray)[<span class="number">4</span>])</span>`</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//定义变量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> ArrayTemp[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line">    <span class="comment">//初始化变量</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ArrayTemp, PlainArray, <span class="number">16</span>);</span><br><span class="line">    <span class="comment">//矩阵乘法4*4</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            PlainArray[i][j] = <span class="built_in">GaloisMultiplication</span>(MixArray[i][<span class="number">0</span>], ArrayTemp[<span class="number">0</span>][j]) ^</span><br><span class="line">                               <span class="built_in">GaloisMultiplication</span>(MixArray[i][<span class="number">1</span>], ArrayTemp[<span class="number">1</span>][j]) ^</span><br><span class="line">                               <span class="built_in">GaloisMultiplication</span>(MixArray[i][<span class="number">2</span>], ArrayTemp[<span class="number">2</span>][j]) ^</span><br><span class="line">                               <span class="built_in">GaloisMultiplication</span>(MixArray[i][<span class="number">3</span>], ArrayTemp[<span class="number">3</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>我们发现在矩阵乘法中，出现了加法和乘法运算，在扩展域中加法操作等同于异或运算，而乘法操作需要一个特殊的方式进行处理，于是我们就先把代码中的加号换成异或符号，然后将伽罗瓦域的乘法定义成一个有两个参数的函数，并让他返回最后计算结果。于是列混淆的代码就会变成下面的样子：</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///////////////////////////////////////////////////////////////`</span></span><br><span class="line"><span class="comment">//功能: 伽罗瓦域内的乘法运算 GF(128)</span></span><br><span class="line"><span class="comment">//参数: Num_L 输入的左参数</span></span><br><span class="line"><span class="comment">//Num_R 输入的右参数</span></span><br><span class="line"><span class="comment">//返回值:计算结果</span></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">GaloisMultiplication</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Num_L, <span class="type">unsigned</span> <span class="type">char</span> Num_R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义变量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> Result = <span class="number">0</span>; <span class="comment">//伽罗瓦域内乘法计算的结果</span></span><br><span class="line">    <span class="keyword">while</span>(Num_L)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果Num_L最低位是1就异或Num_R，相当于加上Num_R * 1</span></span><br><span class="line">        <span class="keyword">if</span>(Num_L &amp; <span class="number">0x01</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        Result ^= Num_R;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Num_L右移一位，相当于除以2</span></span><br><span class="line">        Num_L = Num_L &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果Num_R最高位为1</span></span><br><span class="line">        <span class="keyword">if</span>(Num_R &amp; <span class="number">0x80</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//左移一位相当于乘二</span></span><br><span class="line">            Num_R = Num_R &lt;&lt; <span class="number">1</span>;<span class="comment">//注：这里会丢失最高位，但是不用担心</span></span><br><span class="line">            Num_R ^= <span class="number">0x1B</span>;<span class="comment">//计算伽罗瓦域内除法Num_R = Num_R/(x^8(刚好丢失最高位) +x^4+x^3+x^1+1)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//左移一位相当于乘二</span></span><br><span class="line">            Num_R = Num_R &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>在解密的逆向列混淆中与正向列混淆的不同之处在于使用的左乘矩阵不同，它与正向列混淆的左乘矩阵互为逆矩阵，也就是说，数据矩阵同时左乘这两个矩阵后，数据矩阵不会发生任何变化。</p>
<p><strong>正向列混淆处理</strong></p>
<img src="https://raw.githubusercontent.com/745921536/MyImagepost/main/img/202209041400761.png" alt="img" style="zoom:67%;" />



<p><strong>逆向列混淆</strong></p>
<img src="https://raw.githubusercontent.com/745921536/MyImagepost/main/img/202209041400753.png" alt="img" style="zoom:67%;" />



<p><strong>加解密验证</strong></p>
<img src="https://pic3.zhimg.com/80/v2-29de65eb93c100c547f7bd92eb95c9ca_720w.jpg" alt="img" style="zoom:67%;" />


        <h3 id="AES密钥生成"   >
          <a href="#AES密钥生成" class="heading-link"><i class="fas fa-link"></i></a><a href="#AES密钥生成" class="headerlink" title="AES密钥生成"></a><strong>AES密钥生成</strong></h3>
      <img src="https://pic4.zhimg.com/80/v2-3027156eb00bcddcdac69657c8aad1e7_720w.jpg" alt="img" style="zoom:67%;" />



<p>子密钥的生成是以列为单位进行的，一列是32Bit，四列组成子密钥共128Bit。生成子密钥的数量比AES算法的轮数多一个，因为第一个密钥加法层进行密钥漂白时也需要子密钥。密钥漂白是指在AES的输入盒输出中都使用的子密钥的XOR加法。子密钥在图中都存储在W[0]、W[1]、…、W[43]的扩展密钥数组之中。k1-k16表示原始密钥对应的字节，而图中子密钥k0与原始子密钥相同。在生成的扩展密钥中W的下标如果是4的倍数时(从零开始)需要对异或的参数进行G函数处理。扩展密钥生成有关公式如下：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>&lt;= i &lt;= <span class="number">10</span></span><br><span class="line"><span class="number">1</span>&lt;= j &lt;= <span class="number">3</span></span><br><span class="line">w[<span class="number">4</span>i] = W[<span class="number">4</span>(i<span class="number">-1</span>)] + G(W[<span class="number">4</span>i<span class="number">-1</span>]);</span><br><span class="line">w[<span class="number">4</span>i+j] = W[<span class="number">4</span>(i<span class="number">-1</span>)+j] + W[<span class="number">4</span>i<span class="number">-1</span>+j];</span><br></pre></td></tr></table></div></figure>



<p><img src="https://pic2.zhimg.com/80/v2-772b661b3a89b1b3d7ec5fd0a47652e9_720w.jpg" alt="img"></p>
<p>函数G()首先将4个输入字节进行翻转，并执行一个按字节的S盒代换，最后用第一个字节与轮系数Rcon进行异或运算。轮系数是一个有10个元素的一维数组，一个元素1个字节。G()函数存在的目的有两个，一是增加密钥编排中的非线性；二是消除AES中的对称性。这两种属性都是抵抗某些分组密码攻击必要的。</p>
<p><img src="https://raw.githubusercontent.com/745921536/MyImagepost/main/img/202209041406051.png" alt="img"></p>
<p>生成密钥代码:</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于密钥扩展 Rcon[0]作为填充，没有实际用途</span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> Rcon[<span class="number">11</span>] = &#123; <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x04</span>, <span class="number">0x08</span>, <span class="number">0x10</span>, <span class="number">0x20</span>, <span class="number">0x40</span>, <span class="number">0x80</span>, <span class="number">0x1B</span>, <span class="number">0x36</span> &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Key_S_Substitution</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>(*ExtendKeyArray)[<span class="number">44</span>], <span class="type">unsigned</span> <span class="type">int</span> nCol)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	ExtendKeyArray[i][nCol] = S_Table[(ExtendKeyArray[i][nCol]) &gt;&gt; <span class="number">4</span>][(ExtendKeyArray[i][nCol]) &amp; <span class="number">0x0F</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">G_Function</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>(*ExtendKeyArray)[<span class="number">44</span>], <span class="type">unsigned</span> <span class="type">int</span> nCol)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//1、将扩展密钥矩阵的nCol-1列复制到nCol列上，并将nCol列第一行的元素移动到最后一行，其他行数上移一行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	ExtendKeyArray[i][nCol] = ExtendKeyArray[(i + <span class="number">1</span>) % <span class="number">4</span>][nCol - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2、将nCol列进行S盒替换</span></span><br><span class="line">    <span class="built_in">Key_S_Substitution</span>(ExtendKeyArray, nCol);</span><br><span class="line">    <span class="comment">//3、将该列第一行元素与Rcon进行异或运算</span></span><br><span class="line">    ExtendKeyArray[<span class="number">0</span>][nCol] ^= Rcon[nCol / <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CalculateExtendKeyArray</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>(*PasswordArray)[<span class="number">4</span>], <span class="type">unsigned</span> <span class="type">char</span>(*ExtendKeyArray)[<span class="number">44</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//1、将密钥数组放入前四列扩展密钥组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	ExtendKeyArray[i &amp; <span class="number">0x03</span>][i &gt;&gt; <span class="number">2</span>] = PasswordArray[i &amp; <span class="number">0x03</span>][i &gt;&gt; <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2、计算扩展矩阵的后四十列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">11</span>; i++) <span class="comment">//进行十轮循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//(1)如果列号是4的倍数，这执行G函数 否则将nCol-1列复制到nCol列上</span></span><br><span class="line">        <span class="built_in">G_Function</span>(ExtendKeyArray, <span class="number">4</span>*i);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//(2)每一轮中，各列进行异或运算</span></span><br><span class="line">        <span class="comment">// 列号是4的倍数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)<span class="comment">//行号</span></span><br><span class="line">        &#123;</span><br><span class="line">        	ExtendKeyArray[k][<span class="number">4</span> * i] = ExtendKeyArray[k][<span class="number">4</span> * i] ^ ExtendKeyArray[k][<span class="number">4</span> * (i - <span class="number">1</span>)];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其他三列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; <span class="number">4</span>; j++)<span class="comment">//每一轮的列号</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)<span class="comment">//行号</span></span><br><span class="line">            &#123;</span><br><span class="line">            	ExtendKeyArray[k][<span class="number">4</span> * i + j] = ExtendKeyArray[k][<span class="number">4</span> * i + j - <span class="number">1</span>] ^ ExtendKeyArray[k][<span class="number">4</span> * (i - <span class="number">1</span>) + j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="AES解密"   >
          <a href="#AES解密" class="heading-link"><i class="fas fa-link"></i></a><a href="#AES解密" class="headerlink" title="AES解密"></a>AES解密</h3>
      <img src="https://raw.githubusercontent.com/745921536/MyImagepost/main/img/202209041420462.jpg" alt="v2-dc07882aa212bcaebe061a3e05cc3012_r" style="zoom:67%;" />

<p>脚本建议直接使用py的第三方库</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">key = long_to_bytes(<span class="number">0xcb8d493521b47a4cc1ae7e62229266ce</span>)</span><br><span class="line">mi = long_to_bytes(<span class="number">0xbc0aadc0147c5ecce0b140bc9c51d52b46b2b9434de5324bad7fb4b39cdb4b5b</span>)</span><br><span class="line">lun = AES.new(key, mode=AES.MODE_ECB)</span><br><span class="line">flag = lun.decrypt(mi)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></div></figure>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2022/07/17/openEuler%E5%85%AC%E5%BC%80%E8%AF%BE/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">openEuler公开课</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2022/07/02/%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/"><span class="paginator-prev__text">反调试技术</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">
          常见加密算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Tea%E5%8A%A0%E5%AF%86%E5%8F%8A%E5%85%B6%E5%8F%98%E7%A7%8D"><span class="toc-number">1.1.</span> <span class="toc-text">
          Tea加密及其变种</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Tea"><span class="toc-number">1.1.1.</span> <span class="toc-text">
          Tea</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#xTea"><span class="toc-number">1.1.2.</span> <span class="toc-text">
          xTea</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#xxTea"><span class="toc-number">1.1.3.</span> <span class="toc-text">
          xxTea</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Base64"><span class="toc-number">1.2.</span> <span class="toc-text">
          Base64</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.</span> <span class="toc-text">
          哈希函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MD5"><span class="toc-number">1.3.1.</span> <span class="toc-text">
          MD5</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RC4"><span class="toc-number">1.4.</span> <span class="toc-text">
          RC4</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RSA"><span class="toc-number">1.5.</span> <span class="toc-text">
          RSA</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AES"><span class="toc-number">1.6.</span> <span class="toc-text">
          AES</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%86%E9%92%A5%E5%8A%A0%E6%B3%95%E5%B1%82"><span class="toc-number">1.6.1.</span> <span class="toc-text">
          密钥加法层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E4%BB%A3%E6%8D%A2%E5%B1%82"><span class="toc-number">1.6.2.</span> <span class="toc-text">
          字节代换层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E4%BD%8D%E7%A7%BB%E2%80%94%E2%80%94ShiftRows"><span class="toc-number">1.6.3.</span> <span class="toc-text">
          行位移——ShiftRows</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E6%B7%B7%E6%B7%86%E2%80%94%E2%80%94MixColumn"><span class="toc-number">1.6.4.</span> <span class="toc-text">
          列混淆——MixColumn</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AES%E5%AF%86%E9%92%A5%E7%94%9F%E6%88%90"><span class="toc-number">1.6.5.</span> <span class="toc-text">
          AES密钥生成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AES%E8%A7%A3%E5%AF%86"><span class="toc-number">1.6.6.</span> <span class="toc-text">
          AES解密</span></a></li></ol></li></ol></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/131.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">少壮不努力,老大亚托莉</p></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">41</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">4</div><div class="sidebar-ov-state-item__name">分类</div></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2023</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>没有眼的鱼</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script></body></html>